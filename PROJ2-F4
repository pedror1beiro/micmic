#include <avr/io.h>
#include <avr/interrupt.h>

// números de 0 a 9 para os displays de 7 segmentos
const unsigned char digitos[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};

// Flags e variáveis para controle dos switches, displays e contadores
volatile unsigned char flag5ms;  
unsigned char sw1pressionado, sw2pressionado, sw3pressionado, sw4pressionado, sw5pressionado, sw6pressionado;
unsigned char disp1, disp2, disp3, disp4; 
unsigned char pickdisp;         
volatile int cont_rot = 0;       
volatile unsigned char flag_1s = 0; 

// Função para configurar o Timer de 5ms
void timer5ms(void) {
    OCR0 = 77;  // Configura o Timer para uma interrupção a cada 5ms
    TCCR0 = 0b00001111; // Prescaler 1024, CTC mode
    TIMSK |= 0b00000010; // Habilita a interrupção do Timer
    SREG |= 0x80; // Ativa as interrupções globais
}

// Função para configurar o Timer 2 para PWM
void timer2(void) {
    TCCR2 = 0b01100011; // Configura o PWM em modo "Phase Correct" com prescaler 64
}

// Configura a interrupção externa para contar as rotações
void configure_external_interrupt(void) {
    EICRA |= (1 << ISC31); // Configura a interrupção externa INT3 para borda de descida
    EIMSK |= (1 << INT3);  // Habilita a interrupção INT3
    sei();                 
}

// Função de inicialização do sistema
void Inic(void) {
    DDRC = 0xFF;  
    PORTC = 0xFF; 
    DDRA = 0b11000000; 
    PORTA = 0b11000000; 
    DDRB = 0b11100000; 
    PINB = 0b11111111; 
    PORTB = 0b10000000; 

    timer5ms();  // Configura o timer para 5ms
    timer2();    // Configura o timer 2 para PWM
    configure_external_interrupt(); // Configura a interrupção externa para contar rotações
}

// Interrupção do Timer (5ms) e verificação de 1 segundo
ISR(TIMER0_COMP_vect) {
    flag5ms = 1; 
    static unsigned char count_1s = 0; 
    count_1s++;
    if (count_1s >= 200) { 
        flag_1s = 1; 
        count_1s = 0; 
    }
}

// Interrupção externa que conta as rotações do motor
ISR(INT3_vect) {
    cont_rot++; // Incrementa o contador de rotações a cada pulso
}

// Função para garantir que o motor está parado antes de mudar de sentido
void parado(void) {
    if (PORTB == 0b10000000 || PORTB == 0b11100000 || PORTB == 0b01100000 || PORTB == 0b00000000) {
        PORTB = 0b10100000; // Define um sentido de movimento
    }
}

// Função para atualizar os displays de 7 segmentos com os valores de RPM
void updatedisp(void) {
    if (pickdisp == 0) { // Atualiza o display 1
        PORTA = 0b11000000;
        PORTC = digitos[disp1];
    }
    if (pickdisp == 1) { // Atualiza o display 2
        PORTA = 0b10000000;
        PORTC = digitos[disp2];
    }
    if (pickdisp == 2) { // Atualiza o display 3
        PORTA = 0b01000000;
        PORTC = digitos[disp3];
    }
    if (pickdisp == 3) { // Atualiza o display 4
        pickdisp = -1; // Reseta o índice de display
        PORTA = 0b00000000;
        PORTC = digitos[disp4];
    }
    pickdisp++; 
}

// Função para processar o RPM (rotações por minuto) e dividir entre os displays
void processar_display(int rpm) {
    disp1 = rpm % 10; // Unidades
    disp2 = (rpm / 10) % 10; // Dezenas
    disp3 = (rpm / 100) % 10; // Centenas
    disp4 = (rpm / 1000) % 10; // Milhares
}

// Função que verifica os switches e controla o motor e displays
void verify(void) {
    // Controle de velocidade e direção com base nos switches
    if (sw1pressionado == 1) { 
        parado(); 
        OCR2 = (25 * 255) / 100; 
    }
    if (sw2pressionado == 1) { // 50% de velocidade
        parado();
        OCR2 = (50 * 255) / 100; // Ajusta o duty cycle do PWM para 50%
    }
    if (sw3pressionado == 1) { // 70% de velocidade
        parado();
        OCR2 = (70 * 255) / 100; // Ajusta o duty cycle do PWM para 70%
    }
    if (sw4pressionado == 1) { // 90% de velocidade
        parado();
        OCR2 = (90 * 255) / 100; // Ajusta o duty cycle do PWM para 90%
    }
    if (sw5pressionado == 1) { 
        inv = PORTB;
        if (disp3 == 1) {
            disp3 = 0;
        } else {
            disp3 = 1;
        }
        while (cont < 50) { 
            PORTB = 0b00011111 & PORTB; 
            if (flag5ms == 1) {
                updatedisp(); 
                flag5ms = 0;
                if (cont == 49) { 
                    if (inv == 0b10100000) {
                        PORTB = 0b11000000;
                    }
                    if (inv == 0b11000000) {
                        PORTB = 0b10100000;
                    }
                }
                cont++;
            }
        }
        cont = 0; // Reseta o contador
    }
    if (sw6pressionado == 1) { // Para o motor
        OCR2 = 0; // Desliga o PWM
        PORTB = 0b00011111 & PORTB; // Garante que o motor está parado
    }
}

int main(void) {
    Inic();  
    flag5ms = 0;  
    pickdisp = 0; 
    sw1pressionado = sw2pressionado = sw3pressionado = sw4pressionado = sw5pressionado = sw6pressionado = 0; 

    while (1) {
        if (flag_1s) {
            int rpm = (cont_rot * 30) * OCR2 / 255; // * 30 porque uma volta equivale a duas rotações	
            cont_rot_ant = cont_rot; // Salva a contagem de rotações anterior
            cont_rot = 0; // Reseta o contador de rotações
            processar_display(rpm); // Atualiza os displays com o RPM calculado
            flag_1s = 0; // Reseta a flag de 1 segundo
        }

        switches = PINA & 0b00111111; // Lê o estado dos switches
        switch (switches) {
            case 0b00111110:
                if (temp == 0) { sw1pressionado = 1; temp = 1; } break;
            case 0b00111101:
                if (temp == 0) { sw2pressionado = 1; temp = 1; } break;
            case 0b00111011:
                if (temp == 0) { sw3pressionado = 1; temp = 1; } break;
            case 0b00110111:
                if (temp == 0) { sw4pressionado = 1; temp = 1; } break;
            case 0b00101111:
                if (temp == 0) { sw5pressionado = 1; temp = 1; } break;
            case 0b00011111:
                if (temp == 0) { sw6pressionado = 1; temp = 1; } break;
            default:
                temp = 0; break;
        }

        verify(); 
        sw1pressionado = sw2pressionado = sw3pressionado = sw4pressionado = sw5pressionado = sw6pressionado = 0; 
        updatedisp(); 
    }
}
